// THIS FILE IS AUTOGENERATED - DO NOT EDIT

// SOURCE: /Users/twe/Projects/heliosRX/packages/cli/rules/global/global_types.bolt
// Returns true if the value is intialized to init, or if it retains it's prior
// value, otherwise.
function initial(value, init) { value == (prior(value) == null ? init : prior(value)) }

type Timestamp extends Number {
}

type ServerTimestamp extends Number {
 // same as Timestamp but WITH milliseconds
}

type CurrentTimestamp extends ServerTimestamp {
  validate() { this == now }
}

type InitialTimestamp extends ServerTimestamp {
  validate() { initial(this, now) }
}

type PastTimestamp extends Number {
	validate() { this <= now }
}

type FutureTimestamp extends Number {
	validate() { this >= now }
}

type AnyID extends String {
  validate() { this.length >= 20 }
}

type PushID extends String {
	// Source: https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html
  validate() { this.length == 20 }
}

type UserID extends String {
	// Source: https://firebase.google.com/docs/auth/admin/manage-users
	// Source: https://groups.google.com/forum/#!topic/firebase-talk/5ENGCX8y04M
  validate() { this.length >= 28 && this.length <= 128 }
}

type ReasonableDate extends Number {
  //   200000000 = '1976-05-03'
  // 30000000000 = '2065-01-24'
  validate() { this > 200000000 && this < 30000000000 }
}

type ReasonableYear extends String {
	// YYYY is 20th or 21st century
  validate() { this.test(/^(19|20)\d\d$/) }
}

type YYMMDDDate extends String {
  validate() { this.test(/^\d{2}(((0)[0-9])|((1)[0-2]))([0-2][0-9]|(3)[0-1])$/) }
}

type ISODate extends String {
	// YYYY-MM-DD in 20th or 21st century
	// Note: Does not validate day-of-month is valid.
  validate() { this.test(/^(19|20)\d\d-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/) }
}

type Domain extends String {
  validate() { this.test(/^.+\.(com|org|edu)$/) }
}

type EMail extends String {
  // TODO:
}

type Point2D {
  x: Number, // | Null ?
  y: Number, // | Null ?
}



// SOURCE: /Users/twe/Projects/heliosRX/packages/cli/rules/global/global_functions.bolt
// Checks if user is a specific (authenticated) user
function isUser(uid) { auth != null && auth.uid == uid }

// Check if user is signed in
function isSignedIn() { auth != null }

// Check if user has custom claim 'admin' (not to be confused with 'admin sdk' access)
function isHeliosAdmin() { auth.token.admin === true }

// Check if user has custom claim 'admin'
function isHeliosDeveloper() { auth.token.developer === true || isHeliosAdmin() }

// Check if user has custom claim 'support'
function isHeliosSupport() { auth.token.support === true || isHeliosAdmin() || isHeliosDeveloper() }

// Check if user has verified email address
function emailVerified() { auth.token.email_verified === true }



// SOURCE: ../../src/models//group/schema.bolt

type Group {
	title: String
	unit: String | Null
	matchRegex: String | Null
	createdAt: ServerTimestamp | Null
	description: String | Null
}


// SOURCE: ../../src/models//groupMember/schema.bolt

type GroupMember {
	role: String | Null
}


// SOURCE: ../../src/models//log/schema.bolt

type Log {
	createdAt: ServerTimestamp | Null
	userId: UserID | Null
	value: Number | Null
}


// SOURCE: ../../src/models//user/schema.bolt

type User {
	username: String
	createdAt: ServerTimestamp | Null
}




// SOURCE: /Users/twe/Projects/heliosrx-example-fitness-tracker/rules/rules.bolt
// file: db/rules/rules.bolt

path /groups {
  read() { true }
  write() { true }
}

path /groups/{groupId} is Group {
  read() { true }
  write() { true }
}

path /groups/{groupId}/members/{memberId} is GroupMember {
  read() { true }
  write() { true }
}

path /groups/{groupId}/logs/{logId} is Log {
  read() { true }
  write() { true }
}

path /users/{userId} is User {
  read() { true }
  write() { true }
}


